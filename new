#include <Adafruit_MAX31865.h>
#include <WiFi.h>
#include <ModbusRTUSlave.h>
#include <PID_v2.h>

// Pin Definitions
#define MAX31865_MISO 19
#define MAX31865_MOSI 23
#define MAX31865_CLK 18
#define MAX31865_CS 5
#define MAX485_DE 32
#define MAX485_RE 33
#define MAX485_RX 16
#define MAX485_TX 17
#define SSR_PIN 22

// Wi-Fi Credentials
const char* ssid = "equichem_5";
const char* password = "equichem@2023";

// NTP Time
const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = 19800;  // GMT offset for Asia/Kolkata (UTC+5:30)
const int daylightOffset_sec = 0;

// MAX31865 and RTD Parameters
Adafruit_MAX31865 thermo(MAX31865_CS, MAX31865_MOSI, MAX31865_MISO, MAX31865_CLK);
#define R0 100.0
#define Rref 430.0
#define A 3.9083e-3
#define B -5.775e-7
#define C -4.183e-12

// Modbus
ModbusRTUSlave modbus_slave(Serial1);
uint16_t holdingRegisters[6] = {0}; 
const uint8_t slaveID = 1;
const uint32_t baud = 9600;

// Temperature Variables
#define totalReadingsMAX31865 2
double temperatureReadingsMAX31865[totalReadingsMAX31865] = {0};
float previousEMA = 0.0;
const float alpha = 0.1;  // EMA smoothing factor

// PID Control
double setpoint = 55.0;
double lastSetpoint = 55.0;
double inputTemperature, output;
double Kp = 0.8, Ki = 0.4, Kd = 1.6;  // PID parameters
PID_v2 pidController(&inputTemperature, &output, &setpoint, Kp, Ki, Kd, P_ON_E, DIRECT);

// Timers
unsigned long lastReadingTime = 0;
unsigned long lastControlCycleTime = 0;
const long readingInterval = 250;
const long controlCycleInterval = 6000;

void setup() {
  Serial.begin(115200);

  // Initialize Pins
  pinMode(SSR_PIN, OUTPUT);
  digitalWrite(SSR_PIN, LOW);

  pinMode(MAX485_DE, OUTPUT);
  pinMode(MAX485_RE, OUTPUT);
  receiveMode();

  // Initialize Wi-Fi
  connectWiFi();

  // Initialize NTP
  initializeNTP();

  // Initialize MAX31865
  thermo.begin(MAX31865_3WIRE);

  // Initialize Modbus
  Serial1.begin(baud, SERIAL_8N1, MAX485_RX, MAX485_TX);
  modbus_slave.configureHoldingRegisters(holdingRegisters, 6);
  modbus_slave.begin(slaveID, baud, SERIAL_8N1);

  // Initialize PID
  pidController.SetMode(AUTOMATIC);
  pidController.SetOutputLimits(0, 1000);

  Serial.println("Setup completed.");
}

void loop() {
  modbus_slave.poll();  // Poll Modbus
  updateSetpoint();     // Update setpoint if changed
  readTemperature();    // Read temperature from MAX31865
  performPIDControl();  // Perform PID-based control
}

void connectWiFi() {
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
  Serial.println("WiFi connected.");
}

void initializeNTP() {
  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  struct tm timeinfo;
  for (int i = 0; i < 5; i++) {
    if (getLocalTime(&timeinfo)) {
      Serial.println("Time synchronized.");
      break;
    }
    delay(1000);
    Serial.println("Retrying NTP synchronization...");
  }
}

void updateSetpoint() {
  double newSetpoint = holdingRegisters[0] / 10.0;  // Convert from tenths of degrees
  if (abs(newSetpoint - lastSetpoint) > 0.1) {
    setpoint = newSetpoint;
    lastSetpoint = setpoint;
  }
  if (setpoint < 25.0) setpoint = 25.0;
  if (setpoint > 60.0) setpoint = 60.0;
}

void readTemperature() {
  if (millis() - lastReadingTime < readingInterval) return;
  lastReadingTime = millis();

  // Read temperature
  for (int i = 0; i < totalReadingsMAX31865; i++) {
    uint16_t adcCode = thermo.readRTD();
    float Rt = (adcCode * Rref) / 32768.0;
    temperatureReadingsMAX31865[i] = Rt;
  }

  double tempSum = 0;
  for (int i = 0; i < totalReadingsMAX31865; i++) {
    tempSum += temperatureReadingsMAX31865[i];
  }

  float avgRt = tempSum / totalReadingsMAX31865;
  float rawTemperature = calculateTemperature(avgRt);

  previousEMA = alpha * rawTemperature + (1 - alpha) * previousEMA;
  float adjustedTemperature = previousEMA - 0.1;

  // Update Modbus register
  holdingRegisters[1] = (uint16_t)(adjustedTemperature * 10);

  // Update time in Modbus
  updateTimeInModbus();

  Serial.printf("Temperature: %.2f°C, Adjusted: %.2f°C, Setpoint: %.1f°C\n", 
                previousEMA, adjustedTemperature, setpoint);
}

void updateTimeInModbus() {
  struct tm timeinfo;
  if (getLocalTime(&timeinfo)) {
    holdingRegisters[2] = timeinfo.tm_hour;
    holdingRegisters[3] = timeinfo.tm_min;
    holdingRegisters[4] = timeinfo.tm_sec;
    holdingRegisters[5] = millis() % 1000;
  } else {
    Serial.println("Failed to get local time.");
  }
}

void performPIDControl() {
  if (millis() - lastControlCycleTime < controlCycleInterval) return;
  lastControlCycleTime = millis();

  inputTemperature = previousEMA;
  pidController.Compute();

  if (output > 0) {
    digitalWrite(SSR_PIN, HIGH);
    Serial.println("Heater ON");
  } else {
    digitalWrite(SSR_PIN, LOW);
    Serial.println("Heater OFF");
  }

  Serial.printf("PID Output: %.2f\n", output);
}

float calculateTemperature(float Rt) {
  if (Rt >= R0) {
    return (-A + sqrt(A * A - 4 * B * (1 - Rt / R0))) / (2 * B);
  }

  float t = Rt;
  float diff, tolerance = 0.001;
  int iteration = 0, maxIterations = 100;

  do {
    float fValue = R0 * (1 + A * t + B * t * t + C * (t - 100) * t * t * t) - Rt;
    float fDerivative = R0 * (A + 2 * B * t + 3 * C * (t - 100) * t * t + C * t * t * t);
    float nextT = t - fValue / fDerivative;
    diff = abs(nextT - t);
    t = nextT;
    iteration++;
  } while (diff > tolerance && iteration < maxIterations);

  if (iteration == maxIterations) {
    Serial.println("Temperature calculation failed to converge.");
  }
  return t;
}

void transmitMode() {
  digitalWrite(MAX485_DE, HIGH);
  digitalWrite(MAX485_RE, HIGH);
}

void receiveMode() {
  digitalWrite(MAX485_DE, LOW);
  digitalWrite(MAX485_RE, LOW);
}