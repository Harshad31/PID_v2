#include <Arduino.h>
#include <Adafruit_MAX31865.h>
#include <ESPModbusRTU.h>
#include <PID_v2.h>
#include <WiFi.h>

// RS485 Direction Control
#define MAX485_DE 32
#define MAX485_RE 32  // Same pin for TX/RX control

// MAX31865 SPI Configuration
#define MAX31865_MISO 19
#define MAX31865_MOSI 23
#define MAX31865_CLK 18
#define MAX31865_CS 5

// RS485 UART Configuration
#define MAX485_RX 16
#define MAX485_TX 17

// SSR (Heater) Control
#define SSR_PIN 22

// Modbus Slave Configuration
#define MODBUS_SLAVE_ID 1
#define BAUD_RATE 9600

// Wi-Fi Credentials (Optional, used for debugging)
const char* ssid = "equichem_5";
const char* password = "equichem@2023";

// NTP Time Configuration
const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = 19800;
const int daylightOffset_sec = 0;

// MAX31865 (PT100) Sensor
Adafruit_MAX31865 thermo = Adafruit_MAX31865(MAX31865_CS, MAX31865_MOSI, MAX31865_MISO, MAX31865_CLK);

// Modbus RTU Slave Instance
ModbusRTU modbus_slave;

// Holding Registers (10 registers for storing values)
uint16_t holdingRegisters[10] = {0};

// PID Control Variables
double setpoint = 40.0;
double inputTemperature = 0.0, output = 0.0;
double Kp = 0.8, Ki = 0.1, Kd = 1.3;

// PID Controller
PID_v2 pidController(&inputTemperature, &output, &setpoint, Kp, Ki, Kd, P_ON_E, DIRECT);

// Exponential Moving Average (EMA) Filter
float previousEMA = 0.0;
const float alpha = 0.1;

// Timing Variables
unsigned long lastReadingTime = 0;
unsigned long lastControlCycleTime = 0;
const long readingInterval = 500;
const long controlCycleInterval = 5000;

void setup() {
    Serial.begin(115200);
    
    pinMode(SSR_PIN, OUTPUT);
    digitalWrite(SSR_PIN, LOW);  // Turn SSR off initially

    // RS485 Direction Control
    pinMode(MAX485_DE, OUTPUT);
    pinMode(MAX485_RE, OUTPUT);
    digitalWrite(MAX485_DE, LOW);
    digitalWrite(MAX485_RE, LOW);

    // Wi-Fi Connection
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
        Serial.println("Connecting to WiFi...");
        delay(1000);
    }
    Serial.println("WiFi connected.");

    // NTP Time Sync
    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
    
    // Initialize MAX31865 Sensor
    thermo.begin(MAX31865_3WIRE);

    // Initialize PID Controller
    pidController.SetMode(AUTOMATIC);
    pidController.SetOutputLimits(0, 255);

    // Initialize Modbus RTU (RS-485)
    Serial1.begin(BAUD_RATE, SERIAL_8N1, MAX485_RX, MAX485_TX);
    modbus_slave.begin(&Serial1, MODBUS_SLAVE_ID);
    modbus_slave.addHreg(0, 10); // 10 Holding Registers

    Serial.println("Modbus RTU Slave Initialized");

    // Create Tasks
    xTaskCreatePinnedToCore(readTemperatureTask, "Read Temperature", 2048, NULL, 1, NULL, 0);
    xTaskCreatePinnedToCore(modbusUpdateTask, "Modbus Update", 2048, NULL, 1, NULL, 1);
    xTaskCreatePinnedToCore(controlSSRTask, "Control SSR", 2048, NULL, 1, NULL, 0);
}

void loop() {
    // Modbus task will be handled in FreeRTOS tasks
}

void readTemperatureTask(void *pvParameters) {
    TickType_t xLastWakeTime = xTaskGetTickCount();
    while (1) {
        vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(readingInterval));

        // Read MAX31865 Sensor
        uint16_t adcCode = thermo.readRTD();
        float Rt = (adcCode * 430.0) / 32768.0;
        float temperature = calculateTemperature(Rt);

        // Apply Exponential Moving Average (EMA)
        previousEMA = alpha * temperature + (1 - alpha) * previousEMA;
        inputTemperature = previousEMA - 0.1;

        // Update Modbus Holding Register
        modbus_slave.Hreg(1, (uint16_t)(inputTemperature * 10));  // Store temperature in tenths

        Serial.print("Temperature: ");
        Serial.print(inputTemperature, 2);
        Serial.println("Â°C");
    }
}

void modbusUpdateTask(void *pvParameters) {
    while (1) {
        modbus_slave.task();  // Poll Modbus for data

        // Read Setpoint from Holding Register
        double newSetpoint = modbus_slave.Hreg(0) / 10.0;

        // Update Setpoint with Limits
        if (newSetpoint >= 35.0 && newSetpoint <= 60.0) {
            setpoint = newSetpoint;
        }

        vTaskDelay(pdMS_TO_TICKS(500));
    }
}

void controlSSRTask(void *pvParameters) {
    while (1) {
        if (millis() - lastControlCycleTime >= controlCycleInterval) {
            lastControlCycleTime = millis();

            // Update PID Control
            pidController.Compute();

            // Control SSR
            if (output > 0) {
                digitalWrite(SSR_PIN, HIGH);
                Serial.println("Heater ON");
            } else {
                digitalWrite(SSR_PIN, LOW);
                Serial.println("Heater OFF");
            }
        }
        vTaskDelay(pdMS_TO_TICKS(controlCycleInterval));
    }
}

// Calculate Temperature from RTD Resistance
float calculateTemperature(float Rt) {
    float R0 = 100.0;
    float A = 3.9083e-3, B = -5.775e-7, C = -4.183e-12;
    float t;

    if (Rt >= R0) {
        t = (-A + sqrt(A * A - 4 * B * (1 - Rt / R0))) / (2 * B);
    } else {
        float tolerance = 0.001;
        int maxIterations = 100, iteration = 0;
        float diff;
        t = Rt;

        do {
            float fValue = R0 * (1 + A * t + B * t * t + C * (t - 100) * t * t * t) - Rt;
            float fDerivative = R0 * (A + 2 * B * t + 3 * C * (t - 100) * t * t + C * t * t * t);
            float nextT = t - fValue / fDerivative;
            diff = abs(nextT - t);
            t = nextT;
            iteration++;
        } while (diff > tolerance && iteration < maxIterations);
    }
    return t;
}
